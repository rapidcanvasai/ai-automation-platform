name: "Daily AI Monitoring - Template"

# TEMPLATE: Copy this file and customize the env section for your DataApp.
# No test steps needed -- the AI agent navigates and verifies the app autonomously.
#
# Compare with the old approach (daily-automation-*.yml) that required 30+ lines
# of hardcoded test steps like:
#   Open https://... Wait 2sec Enter email in email Click Next ...
#
# Now you only need: URL, credentials, and high-level goals.

on:
  schedule:
    # Runs daily at 10:00 UTC -- adjust as needed
    - cron: '0 10 * * *'
  workflow_dispatch:
    inputs:
      monitoring_goals:
        description: 'Override monitoring goals (comma-separated)'
        required: false
        type: string
      max_steps:
        description: 'Max AI steps (higher = more thorough)'
        required: false
        type: number
        default: 25

# ─── CUSTOMIZE THIS SECTION FOR YOUR DATAAPP ────────────────────────────────
env:
  # Application URL to monitor (REQUIRED)
  MONITOR_URL: "https://app.rapidcanvas.ai/apps/YOUR_APP_NAME/YOUR_TENANT"

  # High-level monitoring goals -- the AI decides HOW to achieve them
  # No need for step-by-step instructions!
  MONITORING_GOALS: "Verify the app loads after login, check main features are accessible, verify no error messages appear"

  # AI agent configuration
  MAX_STEPS: 25
  TIMEOUT_MS: 300000  # 5 minutes

  # Slack configuration
  SLACK_CHANNEL: 'your-slack-channel'
  SLACK_CHANNEL_ID: 'YOUR_CHANNEL_ID'
  ENABLE_SLACK: true
  SLACK_NOTIFY_ONLY_FAILURES: true
  SLACK_MENTION: ''  # Optional: Slack user ID to mention

  # Metadata for Slack notifications
  DATAAPP_NAME: 'Your DataApp Name'
  TENANT_NAME: 'Your Tenant Name'
# ─────────────────────────────────────────────────────────────────────────────

jobs:
  monitor:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: Install backend dependencies
      run: |
        cd backend
        npm ci

    - name: Install Playwright browsers
      run: |
        cd backend
        npx playwright install chromium
        npx playwright install-deps chromium

    - name: Build backend
      run: |
        cd backend
        npm run build

    - name: Start backend server
      env:
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        OPENAI_MODEL: "gpt-4o"
        SLACK_CHANNEL_ID: ${{ env.SLACK_CHANNEL_ID }}
        SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      run: |
        cd backend
        DB_DISABLED=true NODE_ENV=development PORT=3001 npm start &

        for i in {1..30}; do
          if curl -f http://localhost:3001/health >/dev/null 2>&1; then
            echo "Backend is ready!"
            break
          fi
          echo "Waiting for backend... ($i/30)"
          sleep 2
        done

    - name: Run AI Monitoring
      env:
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        MONITOR_EMAIL: ${{ secrets.MONITOR_EMAIL }}
        MONITOR_PASSWORD: ${{ secrets.MONITOR_PASSWORD }}
      run: |
        echo "=== AI Monitoring Agent ==="
        echo "URL: $MONITOR_URL"
        echo "Goals: ${{ inputs.monitoring_goals || env.MONITORING_GOALS }}"
        echo "Max Steps: ${{ inputs.max_steps || env.MAX_STEPS }}"
        echo ""

        # Use override goals from workflow_dispatch if provided
        GOALS="${{ inputs.monitoring_goals || env.MONITORING_GOALS }}"

        # Convert comma-separated goals to JSON array
        GOALS_JSON=$(echo "$GOALS" | python3 -c "
        import sys, json
        goals = [g.strip() for g in sys.stdin.read().strip().split(',') if g.strip()]
        print(json.dumps(goals))
        ")

        # Build payload
        jq -n \
          --arg url "$MONITOR_URL" \
          --arg email "$MONITOR_EMAIL" \
          --arg password "$MONITOR_PASSWORD" \
          --argjson goals "$GOALS_JSON" \
          --argjson maxSteps "${{ inputs.max_steps || env.MAX_STEPS }}" \
          --argjson timeoutMs "${TIMEOUT_MS:-300000}" \
          --argjson enableSlack "${ENABLE_SLACK:-true}" \
          '{
            startUrl: $url,
            loginCredentials: { email: $email, password: $password },
            monitoringGoals: $goals,
            maxSteps: $maxSteps,
            timeoutMs: $timeoutMs,
            headless: true,
            slowMoMs: 300,
            enableSlackNotifications: $enableSlack
          }' > /tmp/monitor-payload.json

        echo "Payload (credentials hidden):"
        cat /tmp/monitor-payload.json | jq 'del(.loginCredentials)'
        echo ""

        # Start monitoring
        RESPONSE=$(curl -s -X POST \
          http://localhost:3001/api/ai/monitor \
          -H "Content-Type: application/json" \
          -d @/tmp/monitor-payload.json)

        MONITORING_ID=$(echo "$RESPONSE" | jq -r '.monitoringId // "unknown"')
        echo "Monitoring ID: $MONITORING_ID"
        echo "MONITORING_ID=$MONITORING_ID" >> $GITHUB_ENV

        # Poll for completion
        echo "Waiting for monitoring to complete..."
        POLL_TIMEOUT=600
        POLL_INTERVAL=10
        ELAPSED=0
        COMPLETED=false

        while [ "$ELAPSED" -lt "$POLL_TIMEOUT" ]; do
          sleep $POLL_INTERVAL
          ELAPSED=$((ELAPSED + POLL_INTERVAL))

          STREAM_DATA=$(curl -s -N --max-time 3 "http://localhost:3001/api/ai/stream/$MONITORING_ID" 2>/dev/null || true)

          if echo "$STREAM_DATA" | grep -q '"type":"monitor:complete"'; then
            echo "Monitoring completed!"
            COMPLETED=true
            REPORT=$(echo "$STREAM_DATA" | grep '"type":"monitor:complete"' | tail -1 | sed 's/^data: //')
            echo "$REPORT" > /tmp/monitoring-report.json
            break
          fi

          if echo "$STREAM_DATA" | grep -q '"type":"monitor:error"'; then
            echo "Monitoring error detected"
            COMPLETED=true
            ERROR_DATA=$(echo "$STREAM_DATA" | grep '"type":"monitor:error"' | tail -1 | sed 's/^data: //')
            echo "$ERROR_DATA" > /tmp/monitoring-report.json
            break
          fi

          echo "Running... ($ELAPSED/$POLL_TIMEOUT s)"
        done

        if [ "$COMPLETED" = "false" ]; then
          echo "Monitoring timed out"
          echo '{"status":"error","error":"timeout"}' > /tmp/monitoring-report.json
        fi

        # Display results
        echo ""
        echo "=== MONITORING REPORT ==="
        cat /tmp/monitoring-report.json | jq '.' 2>/dev/null || cat /tmp/monitoring-report.json

        MONITOR_STATUS=$(cat /tmp/monitoring-report.json | jq -r '.report.status // .status // "unknown"' 2>/dev/null)
        echo "MONITOR_STATUS=$MONITOR_STATUS" >> $GITHUB_ENV

        rm -f /tmp/monitor-payload.json

    - name: Evaluate result
      run: |
        echo "## AI Monitoring Report" >> $GITHUB_STEP_SUMMARY
        echo "- **App**: ${{ env.DATAAPP_NAME }} (${{ env.TENANT_NAME }})" >> $GITHUB_STEP_SUMMARY
        echo "- **URL**: ${{ env.MONITOR_URL }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Status**: ${{ env.MONITOR_STATUS }}" >> $GITHUB_STEP_SUMMARY

        if [ "${{ env.MONITOR_STATUS }}" = "healthy" ]; then
          echo "Application is HEALTHY"
        elif [ "${{ env.MONITOR_STATUS }}" = "degraded" ]; then
          echo "Application is DEGRADED"
          echo "- **Note**: Non-critical issues detected" >> $GITHUB_STEP_SUMMARY
        elif [ "${{ env.MONITOR_STATUS }}" = "unhealthy" ] || [ "${{ env.MONITOR_STATUS }}" = "error" ]; then
          echo "Application is UNHEALTHY or ERROR"
          echo "- **Note**: Critical issues detected - review monitoring report" >> $GITHUB_STEP_SUMMARY
          exit 1
        fi

    - name: Upload monitoring artifacts
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: monitoring-${{ env.DATAAPP_NAME }}-${{ github.run_id }}
        path: |
          backend/test-results/
          /tmp/monitoring-report.json
        retention-days: 30
