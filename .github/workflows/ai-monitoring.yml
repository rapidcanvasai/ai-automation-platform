name: AI Monitoring Pipeline

# Reusable workflow: LLM-driven autonomous monitoring that requires NO manual test steps.
# Just provide a URL, credentials, and optional high-level goals.

on:
  workflow_call:
    inputs:
      monitor_url:
        description: 'URL of the application to monitor'
        required: true
        type: string
      monitoring_goals:
        description: 'Comma-separated monitoring goals (e.g., "Verify chatbot loads, send a test message, verify response appears")'
        required: false
        type: string
        default: 'Explore the application and verify it loads correctly'
      max_steps:
        description: 'Maximum number of AI-driven steps (higher = more thorough, slower)'
        required: false
        type: number
        default: 25
      timeout_ms:
        description: 'Overall monitoring timeout in milliseconds'
        required: false
        type: number
        default: 300000
      headless:
        description: 'Run browser in headless mode'
        required: false
        type: boolean
        default: true
      slow_mo_ms:
        description: 'Slow motion delay between actions in ms'
        required: false
        type: number
        default: 300
      slack_channel:
        description: 'Slack channel name for notifications'
        required: false
        type: string
      slack_channel_id:
        description: 'Slack channel ID for notifications'
        required: false
        type: string
      enable_slack:
        description: 'Enable Slack notifications'
        required: false
        type: boolean
        default: true
      slack_notify_only_failures:
        description: 'Send Slack notifications only for failed/unhealthy results'
        required: false
        type: boolean
        default: false
      slack_mention:
        description: 'Slack user to mention (e.g., "Leonardo" or user ID "U123456")'
        required: false
        type: string
      dataapp_name:
        description: 'DataApp name for Slack notifications'
        required: false
        type: string
      tenant_name:
        description: 'Tenant name for Slack notifications'
        required: false
        type: string
    secrets:
      OPENAI_API_KEY:
        required: true
      MONITOR_EMAIL:
        required: true
      MONITOR_PASSWORD:
        required: true
      SLACK_BOT_TOKEN:
        required: false
      SLACK_WEBHOOK_URL:
        required: false

  workflow_dispatch:
    inputs:
      monitor_url:
        description: 'URL of the application to monitor'
        required: true
        type: string
      monitoring_goals:
        description: 'Comma-separated monitoring goals'
        required: false
        type: string
        default: 'Explore the application and verify it loads correctly'
      max_steps:
        description: 'Maximum number of AI-driven steps'
        required: false
        type: number
        default: 25
      timeout_ms:
        description: 'Overall monitoring timeout in milliseconds'
        required: false
        type: number
        default: 300000
      headless:
        description: 'Run browser in headless mode'
        required: false
        type: boolean
        default: true
      slow_mo_ms:
        description: 'Slow motion delay between actions in ms'
        required: false
        type: number
        default: 300
      slack_channel:
        description: 'Slack channel name'
        required: false
        type: string
      slack_channel_id:
        description: 'Slack channel ID'
        required: false
        type: string
      enable_slack:
        description: 'Enable Slack notifications'
        required: false
        type: boolean
        default: true
      slack_notify_only_failures:
        description: 'Send Slack notifications only for failures'
        required: false
        type: boolean
        default: false
      slack_mention:
        description: 'Slack user to mention'
        required: false
        type: string
      dataapp_name:
        description: 'DataApp name for notifications'
        required: false
        type: string
      tenant_name:
        description: 'Tenant name for notifications'
        required: false
        type: string

jobs:
  ai-monitor:
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: Install backend dependencies
      run: |
        cd backend
        npm ci

    - name: Install Playwright browsers
      run: |
        cd backend
        echo "Installing Chromium browser..."
        npx playwright install chromium
        npx playwright install-deps chromium
        echo "Playwright installation completed."

    - name: Build backend
      run: |
        cd backend
        npm run build

    - name: Start backend server
      env:
        OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        OPENAI_MODEL: "gpt-4o"
        SLACK_CHANNEL_ID: ${{ inputs.slack_channel_id }}
        SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      run: |
        cd backend
        DB_DISABLED=true NODE_ENV=development PORT=3001 npm start &
        echo "Backend server starting..."

        # Wait for backend to be ready
        for i in {1..30}; do
          if curl -f http://localhost:3001/health >/dev/null 2>&1; then
            echo "Backend is ready!"
            break
          fi
          echo "Waiting for backend... ($i/30)"
          sleep 2
        done

    - name: Run AI Monitoring
      id: monitoring
      env:
        MONITOR_URL: ${{ inputs.monitor_url }}
        MONITOR_EMAIL: ${{ secrets.MONITOR_EMAIL }}
        MONITOR_PASSWORD: ${{ secrets.MONITOR_PASSWORD }}
        MONITORING_GOALS: ${{ inputs.monitoring_goals }}
        MAX_STEPS: ${{ inputs.max_steps }}
        TIMEOUT_MS: ${{ inputs.timeout_ms }}
        HEADLESS: ${{ inputs.headless }}
        SLOW_MO_MS: ${{ inputs.slow_mo_ms }}
        ENABLE_SLACK: ${{ inputs.enable_slack }}
        SLACK_NOTIFY_ONLY_FAILURES: ${{ inputs.slack_notify_only_failures }}
      run: |
        echo "Starting AI Monitoring for: $MONITOR_URL"
        echo "Goals: $MONITORING_GOALS"
        echo "Max Steps: $MAX_STEPS"

        # Build the monitoring goals array from comma-separated string
        GOALS_JSON=$(echo "$MONITORING_GOALS" | python3 -c "
        import sys, json
        goals = [g.strip() for g in sys.stdin.read().strip().split(',') if g.strip()]
        print(json.dumps(goals))
        ")

        # Determine Slack notification setting
        if [ "$ENABLE_SLACK" = "true" ]; then
          SLACK_ENABLED="true"
        else
          SLACK_ENABLED="false"
        fi

        # Build the monitoring request payload
        jq -n \
          --arg url "$MONITOR_URL" \
          --arg email "$MONITOR_EMAIL" \
          --arg password "$MONITOR_PASSWORD" \
          --argjson goals "$GOALS_JSON" \
          --argjson maxSteps "${MAX_STEPS:-25}" \
          --argjson timeoutMs "${TIMEOUT_MS:-300000}" \
          --argjson headless "${HEADLESS:-true}" \
          --argjson slowMoMs "${SLOW_MO_MS:-300}" \
          --argjson enableSlack "$SLACK_ENABLED" \
          '{
            startUrl: $url,
            loginCredentials: {
              email: $email,
              password: $password
            },
            monitoringGoals: $goals,
            maxSteps: $maxSteps,
            timeoutMs: $timeoutMs,
            headless: $headless,
            slowMoMs: $slowMoMs,
            enableSlackNotifications: $enableSlack
          }' > /tmp/monitor-payload.json

        echo "Monitoring payload:"
        cat /tmp/monitor-payload.json | jq 'del(.loginCredentials)'
        echo ""

        # Call the AI monitoring endpoint
        MONITOR_RESPONSE=$(curl -X POST \
          http://localhost:3001/api/ai/monitor \
          -H "Content-Type: application/json" \
          -d @/tmp/monitor-payload.json \
          -w "\n%{http_code}" \
          --max-time 30)

        HTTP_CODE=$(echo "$MONITOR_RESPONSE" | tail -n1)
        RESPONSE_BODY=$(echo "$MONITOR_RESPONSE" | sed '$d')

        echo "HTTP Code: $HTTP_CODE"
        echo "Response: $RESPONSE_BODY"

        if [ "$HTTP_CODE" -eq 200 ]; then
          MONITORING_ID=$(echo "$RESPONSE_BODY" | jq -r '.monitoringId // "unknown"')
          echo "Monitoring started with ID: $MONITORING_ID"
          echo "MONITORING_ID=$MONITORING_ID" >> $GITHUB_ENV
        else
          echo "Failed to start monitoring"
          exit 1
        fi

        # Wait for monitoring to complete by polling SSE stream
        echo "Waiting for monitoring to complete..."
        echo "Polling monitoring results..."

        POLL_TIMEOUT=600  # 10 minutes max poll
        POLL_INTERVAL=10
        ELAPSED=0
        COMPLETED=false

        while [ "$ELAPSED" -lt "$POLL_TIMEOUT" ]; do
          sleep $POLL_INTERVAL
          ELAPSED=$((ELAPSED + POLL_INTERVAL))

          # Check if the monitoring has completed by reading stream events
          STREAM_DATA=$(curl -s -N --max-time 3 "http://localhost:3001/api/ai/stream/$MONITORING_ID" 2>/dev/null || true)

          if echo "$STREAM_DATA" | grep -q '"type":"monitor:complete"'; then
            echo "Monitoring completed!"
            COMPLETED=true
            # Extract report from stream
            REPORT=$(echo "$STREAM_DATA" | grep '"type":"monitor:complete"' | tail -1 | sed 's/^data: //')
            echo "$REPORT" > /tmp/monitoring-report.json
            break
          fi

          if echo "$STREAM_DATA" | grep -q '"type":"monitor:error"'; then
            echo "Monitoring encountered an error"
            ERROR_DATA=$(echo "$STREAM_DATA" | grep '"type":"monitor:error"' | tail -1 | sed 's/^data: //')
            echo "Error: $ERROR_DATA"
            echo "$ERROR_DATA" > /tmp/monitoring-report.json
            COMPLETED=true
            break
          fi

          echo "Still running... ($ELAPSED/$POLL_TIMEOUT seconds)"
        done

        if [ "$COMPLETED" = "false" ]; then
          echo "Monitoring timed out after ${POLL_TIMEOUT}s"
          echo '{"status": "error", "error": "Monitoring timed out"}' > /tmp/monitoring-report.json
        fi

        # Parse and display results
        if [ -f /tmp/monitoring-report.json ]; then
          echo ""
          echo "=== MONITORING REPORT ==="
          cat /tmp/monitoring-report.json | jq '.' 2>/dev/null || cat /tmp/monitoring-report.json

          # Extract status for workflow outcome
          MONITOR_STATUS=$(cat /tmp/monitoring-report.json | jq -r '.report.status // .status // "unknown"' 2>/dev/null)
          echo "MONITOR_STATUS=$MONITOR_STATUS" >> $GITHUB_ENV
          echo ""
          echo "Overall Status: $MONITOR_STATUS"
        fi

        rm -f /tmp/monitor-payload.json

    - name: Evaluate monitoring result
      run: |
        echo "Monitoring Status: ${{ env.MONITOR_STATUS }}"

        if [ "${{ env.MONITOR_STATUS }}" = "healthy" ]; then
          echo "Application is HEALTHY"
          echo "## Monitoring Result: HEALTHY" >> $GITHUB_STEP_SUMMARY
        elif [ "${{ env.MONITOR_STATUS }}" = "degraded" ]; then
          echo "Application is DEGRADED - some issues detected"
          echo "## Monitoring Result: DEGRADED" >> $GITHUB_STEP_SUMMARY
          echo "Some non-critical issues were detected during monitoring." >> $GITHUB_STEP_SUMMARY
        elif [ "${{ env.MONITOR_STATUS }}" = "unhealthy" ]; then
          echo "Application is UNHEALTHY - critical issues detected"
          echo "## Monitoring Result: UNHEALTHY" >> $GITHUB_STEP_SUMMARY
          echo "Critical issues were detected. Check the monitoring report for details." >> $GITHUB_STEP_SUMMARY
          exit 1
        else
          echo "Monitoring encountered an error"
          echo "## Monitoring Result: ERROR" >> $GITHUB_STEP_SUMMARY
          exit 1
        fi

    - name: Upload monitoring results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: monitoring-results-${{ github.run_id }}
        path: |
          backend/test-results/
          /tmp/monitoring-report.json
        retention-days: 30
