name: Configure AI Test Automation

on:
  workflow_dispatch:
    inputs:
      cron_schedule:
        description: 'Cron schedule (e.g., "0 10 * * *" for daily at 10 AM UTC)'
        required: false
        type: string
        default: '0 10 * * *'
      test_description:
        description: 'Test description in plain English'
        required: false
        type: string
      config_name:
        description: 'Configuration name (for managing multiple schedules)'
        required: false
        type: string
        default: 'default'
      slack_channel:
        description: 'Slack channel for notifications'
        required: false
        type: string
        default: 'test-automation-platform-alerts'
      slack_channel_id:
        description: 'Slack channel ID (e.g., C09F5F2MH8D). You can find this by right-clicking on the channel name in Slack and selecting "Copy link"'
        required: false
        type: string
        default: 'C09F5F2MH8D'
      enable_slack:
        description: 'Enable Slack notifications'
        required: false
        type: boolean
        default: true
      slack_notify_only_failures:
        description: 'Send Slack notifications only for failed tests (only applies if enable_slack is true)'
        required: false
        type: boolean
        default: false
      dataapp_name:
        description: 'DataApp name to display in Slack notifications (only shown for failed tests)'
        required: false
        type: string
      tenant_name:
        description: 'Tenant name to display in Slack notifications (only shown for failed tests)'
        required: false
        type: string

permissions:
  contents: write
  actions: write

env:
  CONFIG_FILE: 'automation-config.json'

jobs:
  configure-automation:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.PERSONAL_ACCESS_TOKEN || secrets.GITHUB_TOKEN }}

    - name: Setup configuration directory
      run: |
        echo " Setting up configuration management..."

        # Create config directory if it doesn't exist
        mkdir -p .github/automation-configs

    - name: Load existing configuration
      id: load-config
      run: |
        echo " Loading existing configuration..."

        CONFIG_PATH=".github/automation-configs/${{ env.CONFIG_FILE }}"

        if [ -f "$CONFIG_PATH" ]; then
          echo " Found existing configuration file"
          cat "$CONFIG_PATH"

          # Extract existing configurations
          EXISTING_CONFIGS=$(cat "$CONFIG_PATH" | jq '.' 2>/dev/null || echo '{}')
          echo "existing_configs<<EOF" >> $GITHUB_OUTPUT
          echo "$EXISTING_CONFIGS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
        else
          echo " No existing configuration found, creating new one"
          echo "existing_configs<<EOF" >> $GITHUB_OUTPUT
          echo '{}' >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
        fi

    - name: Process configuration action
      id: process-action
      run: |
        echo " Processing action: create"

        CONFIG_PATH=".github/automation-configs/${{ env.CONFIG_FILE }}"
        CONFIG_NAME="${{ inputs.config_name }}"

        # Parse existing configs
        EXISTING_CONFIGS='${{ steps.load-config.outputs.existing_configs }}'

        # Always perform create action
        case "create" in
          "create"|"update")
            echo " Creating/Updating configuration: $CONFIG_NAME"

        # Validate cron schedule
        if [ -z "${{ inputs.cron_schedule }}" ]; then
          echo " Cron schedule is required for create/update"
          exit 1
        fi

        # Validate cron format (basic validation)
        CRON_REGEX="^[0-9\*\/\-\,]+ [0-9\*\/\-\,]+ [0-9\*\/\-\,]+ [0-9\*\/\-\,]+ [0-9\*\/\-\,]+$"
        if ! echo "${{ inputs.cron_schedule }}" | grep -E "$CRON_REGEX" > /dev/null; then
          echo " Invalid cron schedule format: ${{ inputs.cron_schedule }}"
          echo " Expected format: minute hour day month dayOfWeek"
          echo " Example: 0 10 * * * (daily at 10 AM UTC)"
          exit 1
        fi

        # Validate test description
        if [ -z "${{ inputs.test_description }}" ]; then
          echo " Test description is required for create/update"
          exit 1
        fi

        # Validate test description length
        # Use printf to safely handle special characters in test description
        TEST_DESCRIPTION=$(printf '%s' "${{ inputs.test_description }}")
        if [ ${#TEST_DESCRIPTION} -lt 10 ]; then
          echo " Test description too short (minimum 10 characters)"
          echo " Please provide more detailed test steps"
          exit 1
        fi

        # Validate configuration name
        if [ -z "$CONFIG_NAME" ]; then
          echo " Configuration name is required"
          exit 1
        fi

        # Validate configuration name format
        if ! echo "$CONFIG_NAME" | grep -E "^[a-zA-Z0-9_-]+$" > /dev/null; then
          echo " Invalid configuration name: $CONFIG_NAME"
          echo " Only alphanumeric characters, hyphens, and underscores allowed"
          exit 1
        fi

            # Create new configuration
            NEW_CONFIG=$(jq -n \
              --arg name "$CONFIG_NAME" \
              --arg cron "${{ inputs.cron_schedule }}" \
              --arg description "$TEST_DESCRIPTION" \
              --arg slack_channel "${{ inputs.slack_channel }}" \
              --arg slack_channel_id "${{ inputs.slack_channel_id }}" \
              --argjson headless "true" \
              --argjson enable_slack "${{ inputs.enable_slack }}" \
              --argjson slack_notify_only_failures "${{ inputs.slack_notify_only_failures }}" \
              --arg dataapp_name "${{ inputs.dataapp_name }}" \
              --arg tenant_name "${{ inputs.tenant_name }}" \
              --arg slack_mention "" \
              --arg created_at "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
              --arg created_by "${{ github.actor }}" \
              '{
                name: $name,
                cron_schedule: $cron,
                test_description: $description,
                slack_channel: $slack_channel,
                slack_channel_id: $slack_channel_id,
                headless: $headless,
                enable_slack: $enable_slack,
                slack_notify_only_failures: $slack_notify_only_failures,
                slack_mention: $slack_mention,
                dataapp_name: $dataapp_name,
                tenant_name: $tenant_name,
                created_at: $created_at,
                created_by: $created_by,
                last_updated: $created_at,
                updated_by: $created_by,
                is_active: true
              }')

            # Update existing configs
            UPDATED_CONFIGS=$(echo "$EXISTING_CONFIGS" | jq --arg name "$CONFIG_NAME" --argjson config "$NEW_CONFIG" '. + {($name): $config}')

            echo " Configuration created/updated successfully"
            echo "config_name<<EOF" >> $GITHUB_OUTPUT
            echo "$CONFIG_NAME" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            ;;

          "delete")
            echo " Deleting configuration: $CONFIG_NAME"

            if [ "$CONFIG_NAME" = "default" ]; then
              echo " Cannot delete default configuration"
              exit 1
            fi

            # Remove configuration
            UPDATED_CONFIGS=$(echo "$EXISTING_CONFIGS" | jq --arg name "$CONFIG_NAME" 'del(.[$name])')

            echo " Configuration deleted successfully"
            echo "config_name<<EOF" >> $GITHUB_OUTPUT
            echo "$CONFIG_NAME" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            ;;

          "list")
            echo " Listing all configurations:"
            echo "$EXISTING_CONFIGS" | jq '.'

            CONFIG_COUNT=$(echo "$EXISTING_CONFIGS" | jq 'length')
            echo "Total configurations: $CONFIG_COUNT"

            echo "config_name<<EOF" >> $GITHUB_OUTPUT
            echo "list" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            UPDATED_CONFIGS="$EXISTING_CONFIGS"
            ;;

          "test-run")
            echo " Running test with configuration: $CONFIG_NAME"

            # Get configuration
            SELECTED_CONFIG=$(echo "$EXISTING_CONFIGS" | jq --arg name "$CONFIG_NAME" '.[$name]')

            if [ "$SELECTED_CONFIG" = "null" ]; then
              echo " Configuration '$CONFIG_NAME' not found"
              exit 1
            fi

            echo "config_name<<EOF" >> $GITHUB_OUTPUT
            echo "$CONFIG_NAME" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            UPDATED_CONFIGS="$EXISTING_CONFIGS"
            ;;

          "view")
            echo " Viewing configuration: $CONFIG_NAME"

            # Get configuration
            SELECTED_CONFIG=$(echo "$EXISTING_CONFIGS" | jq --arg name "$CONFIG_NAME" '.[$name]')

            if [ "$SELECTED_CONFIG" = "null" ]; then
              echo " Configuration '$CONFIG_NAME' not found"
              exit 1
            fi

            echo " Configuration details:"
            echo "$SELECTED_CONFIG" | jq '.'

            echo "config_name<<EOF" >> $GITHUB_OUTPUT
            echo "$CONFIG_NAME" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            UPDATED_CONFIGS="$EXISTING_CONFIGS"
            ;;

          "enable")
            echo " Enabling configuration: $CONFIG_NAME"

            # Get configuration
            SELECTED_CONFIG=$(echo "$EXISTING_CONFIGS" | jq --arg name "$CONFIG_NAME" '.[$name]')

            if [ "$SELECTED_CONFIG" = "null" ]; then
              echo " Configuration '$CONFIG_NAME' not found"
              exit 1
            fi

            # Update is_active to true
            UPDATED_CONFIG=$(echo "$SELECTED_CONFIG" | jq '.is_active = true | .last_updated = "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'" | .updated_by = "'${{ github.actor }}'"')
            UPDATED_CONFIGS=$(echo "$EXISTING_CONFIGS" | jq --arg name "$CONFIG_NAME" --argjson config "$UPDATED_CONFIG" '. + {($name): $config}')

            echo " Configuration enabled successfully"
            echo "config_name<<EOF" >> $GITHUB_OUTPUT
            echo "$CONFIG_NAME" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            ;;

          "disable")
            echo " Disabling configuration: $CONFIG_NAME"

            # Get configuration
            SELECTED_CONFIG=$(echo "$EXISTING_CONFIGS" | jq --arg name "$CONFIG_NAME" '.[$name]')

            if [ "$SELECTED_CONFIG" = "null" ]; then
              echo " Configuration '$CONFIG_NAME' not found"
              exit 1
            fi

            # Update is_active to false
            UPDATED_CONFIG=$(echo "$SELECTED_CONFIG" | jq '.is_active = false | .last_updated = "'$(date -u +%Y-%m-%dT%H:%M:%SZ)'" | .updated_by = "'${{ github.actor }}'"')
            UPDATED_CONFIGS=$(echo "$EXISTING_CONFIGS" | jq --arg name "$CONFIG_NAME" --argjson config "$UPDATED_CONFIG" '. + {($name): $config}')

            echo " Configuration disabled successfully"
            echo "config_name<<EOF" >> $GITHUB_OUTPUT
            echo "$CONFIG_NAME" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            ;;

          *)
            echo " Unknown action: create"
            exit 1
            ;;
        esac

        # Save updated configs
        echo "updated_configs<<EOF" >> $GITHUB_OUTPUT
        echo "$UPDATED_CONFIGS" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

    - name: Save configuration
      if: steps.process-action.outputs.config_name != 'list' && steps.process-action.outputs.config_name != 'view'
      run: |
        echo " Saving configuration..."

        CONFIG_PATH=".github/automation-configs/${{ env.CONFIG_FILE }}"
        UPDATED_CONFIGS='${{ steps.process-action.outputs.updated_configs }}'

        # Save to file
        echo "$UPDATED_CONFIGS" | jq '.' > "$CONFIG_PATH"

        echo " Configuration saved to: $CONFIG_PATH"
        echo " Configuration content:"
        cat "$CONFIG_PATH"

    - name: Create scheduled workflow file
      run: |
        echo " Creating scheduled workflow file..."
        echo " Debug: action = create"
        echo " Debug: steps.process-action.outputs.config_name = ${{ steps.process-action.outputs.config_name }}"
        echo " Debug: steps.process-action.outputs.updated_configs = [JSON data provided]"

        CONFIG_NAME="${{ steps.process-action.outputs.config_name }}"

        if [ -z "$CONFIG_NAME" ]; then
          echo " CONFIG_NAME is empty! This step will fail."
          exit 1
        fi

        # Get the configuration data from the step output instead of file
        CONFIG_DATA='${{ steps.process-action.outputs.updated_configs }}'
        # Use temporary file to avoid shell syntax issues with special characters in JSON
        echo "$CONFIG_DATA" > /tmp/config_data.json
        SELECTED_CONFIG=$(cat /tmp/config_data.json | jq --arg name "$CONFIG_NAME" '.[$name]')

        if [ "$SELECTED_CONFIG" = "null" ]; then
          echo " SELECTED_CONFIG is null! This step will fail."
          echo "CONFIG_DATA: $CONFIG_DATA"
          exit 1
        fi

        CRON_SCHEDULE=$(echo "$SELECTED_CONFIG" | jq -r '.cron_schedule')
        # Safely extract test description to avoid shell syntax issues with special characters
        # Use a temporary file to avoid shell variable assignment issues
        echo "$SELECTED_CONFIG" | jq -r '.test_description' > /tmp/test_desc_from_json.txt
        TEST_DESCRIPTION=$(cat /tmp/test_desc_from_json.txt)

        # Sanitize config name for filename
        SANITIZED_CONFIG_NAME=$(echo "$CONFIG_NAME" | sed 's/ /-/g' | sed 's/[^a-zA-Z0-9-]//g' | tr '[:upper:]' '[:lower:]')
        WORKFLOW_FILE=".github/workflows/daily-automation-$SANITIZED_CONFIG_NAME.yml"

        echo " Cron Schedule: $CRON_SCHEDULE"
        echo " Test Description Length: ${#TEST_DESCRIPTION}"
        echo " Workflow File: $WORKFLOW_FILE"
        
        # Debug: Check if TEST_DESCRIPTION is empty
        if [ -z "$TEST_DESCRIPTION" ]; then
          echo " ERROR: TEST_DESCRIPTION is empty!"
          echo " SELECTED_CONFIG content:"
          echo "$SELECTED_CONFIG" | jq '.'
          exit 1
        fi

        # We're already on main branch

        # Create a self-contained workflow based on create-test-scenario.yml
        # Copy the working create-test-scenario.yml and modify it for scheduled runs
        
        # Debug: Check if template file exists (try multiple possible paths)
        echo "Debug: Checking for template file..."
        TEMPLATE_FILE=""
        
        # Try different possible paths
        for path in ".github/workflows/create-test-scenario.yml" "$GITHUB_WORKSPACE/.github/workflows/create-test-scenario.yml" "/github/workspace/.github/workflows/create-test-scenario.yml"; do
          if [ -f "$path" ]; then
            TEMPLATE_FILE="$path"
            echo "‚úÖ Template file found: $path"
            break
          else
            echo "‚ùå Template file not found: $path"
          fi
        done
        
        if [ -z "$TEMPLATE_FILE" ]; then
          echo "‚ùå Template file not found in any expected location"
          echo "Current directory: $(pwd)"
          echo "GITHUB_WORKSPACE: $GITHUB_WORKSPACE"
          echo "Files in current directory:"
          ls -la
          echo "Files in .github/workflows/:"
          ls -la .github/workflows/ || echo "No .github/workflows directory"
          exit 1
        fi
        
        # Copy the template file
        echo "Debug: Copying template file from: $TEMPLATE_FILE"
        cp "$TEMPLATE_FILE" "$WORKFLOW_FILE"
        
        # Verify the copy worked
        if [ -f "$WORKFLOW_FILE" ]; then
          echo "‚úÖ Template file copied successfully to: $WORKFLOW_FILE"
        else
          echo "‚ùå Failed to copy template file to: $WORKFLOW_FILE"
          exit 1
        fi

        # Update the workflow name (Cross-platform compatible)
        echo "Debug: Updating workflow name..."
        echo "Debug: CONFIG_NAME = $CONFIG_NAME"
        echo "Debug: WORKFLOW_FILE = $WORKFLOW_FILE"
        echo "Debug: Checking if workflow file exists..."
        if [ -f "$WORKFLOW_FILE" ]; then
          echo "‚úÖ Workflow file exists"
          echo "Debug: First line of workflow file:"
          head -1 "$WORKFLOW_FILE"
        else
          echo "‚ùå Workflow file does not exist: $WORKFLOW_FILE"
          exit 1
        fi
        
        # Use cross-platform sed approach - create temp file and replace
        echo "Debug: Running sed command..."
        # Use a safer approach with perl instead of sed to avoid escaping issues
        perl -i -pe "s/name: AI Test Automation Pipeline/name: Daily AI Test Automation - $CONFIG_NAME/" "$WORKFLOW_FILE"
        echo "Debug: Sed command completed"
        
        # Verify workflow name update
        echo "Debug: Verifying workflow name update..."
        if grep -q "name: Daily AI Test Automation - $CONFIG_NAME" "$WORKFLOW_FILE"; then
          echo "‚úÖ Workflow name updated successfully"
          echo "Debug: New workflow name:"
          head -1 "$WORKFLOW_FILE"
        else
          echo "‚ùå Failed to update workflow name"
          echo "Debug: Current first line:"
          head -1 "$WORKFLOW_FILE"
          echo "Debug: Looking for pattern: name: Daily AI Test Automation - $CONFIG_NAME"
          exit 1
        fi

        # Add schedule trigger after the existing workflow_dispatch section (Cross-platform compatible)
        echo "Debug: Adding schedule trigger..."
        echo "  schedule:" > /tmp/schedule.txt
        echo "    - cron: '$CRON_SCHEDULE'" >> /tmp/schedule.txt
        
        # Use cross-platform sed approach - create temp file and replace
        sed "/^on:/r /tmp/schedule.txt" "$WORKFLOW_FILE" > "$WORKFLOW_FILE.tmp" && mv "$WORKFLOW_FILE.tmp" "$WORKFLOW_FILE"
        rm /tmp/schedule.txt
        
        # Verify schedule was added
        if grep -q "schedule:" "$WORKFLOW_FILE"; then
          echo "‚úÖ Schedule trigger added successfully"
        else
          echo "‚ùå Failed to add schedule trigger"
          exit 1
        fi
        # Update environment variables with default values from configuration
        echo "üîß CRITICAL: Starting environment variable replacement..."
        echo "Debug: SELECTED_CONFIG = $SELECTED_CONFIG"
        echo "Debug: WORKFLOW_FILE = $WORKFLOW_FILE"
        echo "Debug: Current working directory: $(pwd)"
        echo "Debug: Files in current directory:"
        ls -la
        echo "Debug: Files in .github/workflows/:"
        ls -la .github/workflows/
        
        # Get config values
        SLACK_CHANNEL=$(echo "$SELECTED_CONFIG" | jq -r '.slack_channel // "general"')
        SLACK_CHANNEL_ID=$(echo "$SELECTED_CONFIG" | jq -r '.slack_channel_id // "C09F5F2MH8D"')
        ENABLE_SLACK=$(echo "$SELECTED_CONFIG" | jq -r '.enable_slack // true')
        SLACK_NOTIFY_ONLY_FAILURES=$(echo "$SELECTED_CONFIG" | jq -r '.slack_notify_only_failures // false')
        HEADLESS=$(echo "$SELECTED_CONFIG" | jq -r '.headless // true')
        SLACK_MENTION=$(echo "$SELECTED_CONFIG" | jq -r '.slack_mention // ""')
        DATAAPP_NAME=$(echo "$SELECTED_CONFIG" | jq -r '.dataapp_name // ""')
        TENANT_NAME=$(echo "$SELECTED_CONFIG" | jq -r '.tenant_name // ""')
        # TEST_DESCRIPTION already safely extracted above, don't override it

        echo "Debug: Extracted config values:"
        echo "  SLACK_CHANNEL: $SLACK_CHANNEL"
        echo "  SLACK_CHANNEL_ID: $SLACK_CHANNEL_ID"
        echo "  ENABLE_SLACK: $ENABLE_SLACK"
        echo "  SLACK_NOTIFY_ONLY_FAILURES: $SLACK_NOTIFY_ONLY_FAILURES"
        echo "  HEADLESS: $HEADLESS"
        echo "  SLACK_MENTION: $SLACK_MENTION"
        echo "  DATAAPP_NAME: $DATAAPP_NAME"
        echo "  TENANT_NAME: $TENANT_NAME"
        echo "  TEST_DESCRIPTION: [Length: ${#TEST_DESCRIPTION} characters]"

        # Replace environment variables with hardcoded values from user configuration
        # This ensures scheduled workflows have fixed values, no dependency on inputs
        
        echo "Debug: Original TEST_DESCRIPTION length: ${#TEST_DESCRIPTION}"
        echo "Debug: TEST_DESCRIPTION length: ${#TEST_DESCRIPTION}"
        echo "Debug: WORKFLOW_FILE: $WORKFLOW_FILE"
        
        # Validate TEST_DESCRIPTION is not empty
        if [ -z "$TEST_DESCRIPTION" ]; then
          echo "‚ùå CRITICAL ERROR: TEST_DESCRIPTION is empty!"
          echo "This means the test description was not properly extracted from the configuration."
          exit 1
        fi
        
        # Verify the workflow file exists before replacement
        if [ ! -f "$WORKFLOW_FILE" ]; then
          echo "‚ùå CRITICAL ERROR: Workflow file does not exist: $WORKFLOW_FILE"
          exit 1
        fi
        
        echo "Debug: Workflow file exists, size: $(wc -c < "$WORKFLOW_FILE") bytes"
        echo "Debug: First 10 lines of workflow file:"
        head -10 "$WORKFLOW_FILE"
        
        # DIRECT REPLACEMENT: Replace the entire env section with hardcoded values
        echo "üîß CRITICAL: Running direct environment variable replacement..."
        echo "Debug: WORKFLOW_FILE = $WORKFLOW_FILE"
        echo "Debug: TEST_DESCRIPTION length = ${#TEST_DESCRIPTION}"
        echo "Debug: SLACK_CHANNEL = '$SLACK_CHANNEL'"
        echo "Debug: SLACK_CHANNEL_ID = '$SLACK_CHANNEL_ID'"
        echo "Debug: ENABLE_SLACK = $ENABLE_SLACK"
        echo "Debug: HEADLESS = $HEADLESS"
        
        # Create the new env section with hardcoded values
        echo "üîß CRITICAL: Creating new env section with hardcoded values..."
        {
          echo "env:"
          echo "  TEST_DESCRIPTION: |"
          echo "    TEST_DESCRIPTION_PLACEHOLDER"
          echo "  OPENAI_API_KEY: \$\{\{ secrets.OPENAI_API_KEY \}\}"
          echo "  OPENAI_MODEL: gpt-4o-mini"
          echo "  SLACK_CHANNEL: 'SLACK_CHANNEL_PLACEHOLDER'"
          echo "  SLACK_CHANNEL_ID: 'SLACK_CHANNEL_ID_PLACEHOLDER'"
          echo "  SLACK_BOT_TOKEN: \$\{\{ secrets.SLACK_BOT_TOKEN \}\}"
          echo "  SLACK_WEBHOOK_URL: \$\{\{ secrets.SLACK_WEBHOOK_URL \}\}"
          echo "  ENABLE_SLACK: ENABLE_SLACK_PLACEHOLDER"
          echo "  SLACK_NOTIFY_ONLY_FAILURES: SLACK_NOTIFY_ONLY_FAILURES_PLACEHOLDER"
          echo "  HEADLESS: HEADLESS_PLACEHOLDER"
          if [ -n "$SLACK_MENTION" ]; then
            echo "  SLACK_MENTION: 'SLACK_MENTION_PLACEHOLDER'"
          fi
          echo "  DATAAPP_NAME: 'DATAAPP_NAME_PLACEHOLDER'"
          echo "  TENANT_NAME: 'TENANT_NAME_PLACEHOLDER'"
          echo ""
        } > /tmp/new_env_section.txt
        
        # Replace placeholders with actual values using a simpler approach
        # Create a temporary file with the test description to avoid shell escaping issues
        echo "$TEST_DESCRIPTION" > /tmp/test_description.txt
        
        # Use a simpler approach - replace each placeholder individually
        cp /tmp/new_env_section.txt /tmp/new_env_section_final.txt
        
        # Replace TEST_DESCRIPTION_PLACEHOLDER with the actual test description
        if grep -q "TEST_DESCRIPTION_PLACEHOLDER" /tmp/new_env_section_final.txt; then
          # Create a new file with the test description properly formatted
          {
            head -n 2 /tmp/new_env_section_final.txt  # Keep "env:" and "  TEST_DESCRIPTION: |"
            sed 's/^/    /' /tmp/test_description.txt  # Add proper indentation to each line
            tail -n +4 /tmp/new_env_section_final.txt  # Keep the rest of the file
          } > /tmp/new_env_section_final.txt.tmp
          mv /tmp/new_env_section_final.txt.tmp /tmp/new_env_section_final.txt
        fi
        
        # Replace other placeholders
        sed -i "s/SLACK_CHANNEL_PLACEHOLDER/$SLACK_CHANNEL/g" /tmp/new_env_section_final.txt
        sed -i "s/SLACK_CHANNEL_ID_PLACEHOLDER/$SLACK_CHANNEL_ID/g" /tmp/new_env_section_final.txt
        sed -i "s/ENABLE_SLACK_PLACEHOLDER/$ENABLE_SLACK/g" /tmp/new_env_section_final.txt
        sed -i "s/SLACK_NOTIFY_ONLY_FAILURES_PLACEHOLDER/$SLACK_NOTIFY_ONLY_FAILURES/g" /tmp/new_env_section_final.txt
        sed -i "s/HEADLESS_PLACEHOLDER/$HEADLESS/g" /tmp/new_env_section_final.txt
        if [ -n "$SLACK_MENTION" ]; then
          sed -i "s/SLACK_MENTION_PLACEHOLDER/$SLACK_MENTION/g" /tmp/new_env_section_final.txt
        fi
        sed -i "s/DATAAPP_NAME_PLACEHOLDER/$DATAAPP_NAME/g" /tmp/new_env_section_final.txt
        sed -i "s/TENANT_NAME_PLACEHOLDER/$TENANT_NAME/g" /tmp/new_env_section_final.txt
        
        # Convert escaped GitHub Actions expressions back to proper format
        tr -d '\\' < /tmp/new_env_section_final.txt > /tmp/new_env_section_converted.txt
        mv /tmp/new_env_section_converted.txt /tmp/new_env_section_final.txt
        
        mv /tmp/new_env_section_final.txt /tmp/new_env_section.txt
        
        echo "üîß CRITICAL: New env section created:"
        cat /tmp/new_env_section.txt
        
        # Replace the entire env section
        echo "üîß CRITICAL: Replacing env section in workflow file..."
        # Find the line number where 'env:' starts and where 'jobs:' starts
        ENV_START=$(grep -n "^env:" "$WORKFLOW_FILE" | cut -d: -f1)
        JOBS_START=$(grep -n "^jobs:" "$WORKFLOW_FILE" | cut -d: -f1)
        
        echo "Debug: ENV_START line: $ENV_START"
        echo "Debug: JOBS_START line: $JOBS_START"
        
        if [ -n "$ENV_START" ] && [ -n "$JOBS_START" ]; then
            # Create new file with hardcoded env section
            head -n $((ENV_START - 1)) "$WORKFLOW_FILE" > "$WORKFLOW_FILE.tmp"
            cat /tmp/new_env_section.txt >> "$WORKFLOW_FILE.tmp"
            tail -n +$JOBS_START "$WORKFLOW_FILE" >> "$WORKFLOW_FILE.tmp"
            
            if mv "$WORKFLOW_FILE.tmp" "$WORKFLOW_FILE"; then
                echo "‚úÖ SUCCESS: Environment section replaced with hardcoded values"
            else
                echo "‚ùå ERROR: Failed to move temp file"
                exit 1
            fi
        else
            echo "‚ùå ERROR: Could not find env: or jobs: sections"
            exit 1
        fi
        
        # Clean up
        rm -f /tmp/new_env_section.txt /tmp/test_description.txt /tmp/test_desc_from_json.txt /tmp/config_data.json
        
        # CRITICAL: Replace inputs.headless with env.HEADLESS for scheduled workflows
        echo "üîß CRITICAL: Replacing inputs.headless with env.HEADLESS..."
        # Use perl for robust replacement
        perl -i -pe 's/\$\{\{ inputs\.headless \}\}/\$\{\{ env\.HEADLESS \}\}/g' "$WORKFLOW_FILE"
        
        # Verify the replacement worked
        echo "üîç VERIFICATION: Checking for remaining inputs.headless references..."
        if grep -q "\${{ inputs.headless }}" "$WORKFLOW_FILE"; then
          echo "‚ùå WARNING: Found remaining inputs.headless references:"
          grep "\${{ inputs.headless }}" "$WORKFLOW_FILE"
        else
          echo "‚úÖ SUCCESS: inputs.headless replaced with env.HEADLESS"
        fi
        
        # Verify the replacements worked
        echo "üîç VERIFICATION: Checking all environment variables..."
        echo "Debug: TEST_DESCRIPTION:"
        grep "TEST_DESCRIPTION:" "$WORKFLOW_FILE" || echo "TEST_DESCRIPTION not found"
        echo "Debug: SLACK_CHANNEL:"
        grep "SLACK_CHANNEL:" "$WORKFLOW_FILE" || echo "SLACK_CHANNEL not found"
        echo "Debug: ENABLE_SLACK:"
        grep "ENABLE_SLACK:" "$WORKFLOW_FILE" || echo "ENABLE_SLACK not found"
        echo "Debug: HEADLESS:"
        grep "HEADLESS:" "$WORKFLOW_FILE" || echo "HEADLESS not found"
        
        # Critical validation: Ensure TEST_DESCRIPTION is hardcoded, not using inputs
        if grep -q "TEST_DESCRIPTION: \${{ inputs.test_description }}" "$WORKFLOW_FILE"; then
          echo "‚ùå CRITICAL ERROR: TEST_DESCRIPTION still using input variable!"
          echo "The environment variable replacement failed."
          exit 1
        elif grep -q "TEST_DESCRIPTION:" "$WORKFLOW_FILE"; then
          echo "‚úÖ SUCCESS: TEST_DESCRIPTION is properly hardcoded"
        else
          echo "‚ùå ERROR: TEST_DESCRIPTION not found in workflow file"
          exit 1
        fi
        
        # FINAL VERIFICATION: Check all environment variables after all replacements
        echo "üîç FINAL VERIFICATION: Checking all environment variables..."
        echo "Debug: Final TEST_DESCRIPTION line:"
        grep "TEST_DESCRIPTION:" "$WORKFLOW_FILE" || echo "TEST_DESCRIPTION not found"
        echo "Debug: Final SLACK_CHANNEL line:"
        grep "SLACK_CHANNEL:" "$WORKFLOW_FILE" || echo "SLACK_CHANNEL not found"
        echo "Debug: Final ENABLE_SLACK line:"
        grep "ENABLE_SLACK:" "$WORKFLOW_FILE" || echo "ENABLE_SLACK not found"
        echo "Debug: Final SLACK_NOTIFY_ONLY_FAILURES line:"
        grep "SLACK_NOTIFY_ONLY_FAILURES:" "$WORKFLOW_FILE" || echo "SLACK_NOTIFY_ONLY_FAILURES not found"
        echo "Debug: Final HEADLESS line:"
        grep "HEADLESS:" "$WORKFLOW_FILE" || echo "HEADLESS not found"
        
        echo "üîç FINAL VERIFICATION: Complete env section:"
        sed -n '/^env:/,/^jobs:/p' "$WORKFLOW_FILE" | head -10

        # Verify the file was created and validate content
        if [ -f "$WORKFLOW_FILE" ]; then
          echo " Workflow file exists: $WORKFLOW_FILE"
          echo " File size: $(wc -c < "$WORKFLOW_FILE") bytes"
          echo " File content preview:"
          head -5 "$WORKFLOW_FILE"
          
          # Validate workflow file content
          echo " Validating workflow file content..."
          
          # Check for required sections
          if ! grep -q "^name:" "$WORKFLOW_FILE"; then
            echo " ‚ùå ERROR: Workflow file missing 'name' field"
            exit 1
          fi
          
          if ! grep -q "^on:" "$WORKFLOW_FILE"; then
            echo " ‚ùå ERROR: Workflow file missing 'on' trigger"
            exit 1
          fi
          
          if ! grep -q "^env:" "$WORKFLOW_FILE"; then
            echo " ‚ùå ERROR: Workflow file missing 'env' section"
            exit 1
          fi
          
          if ! grep -q "^jobs:" "$WORKFLOW_FILE"; then
            echo " ‚ùå ERROR: Workflow file missing 'jobs' section"
            exit 1
          fi
          
          # Check for schedule trigger
          if ! grep -q "schedule:" "$WORKFLOW_FILE"; then
            echo " ‚ùå ERROR: Workflow file missing 'schedule' trigger"
            exit 1
          fi
          
          # Check for test description
          if ! grep -q "TEST_DESCRIPTION:" "$WORKFLOW_FILE"; then
            echo " ‚ùå ERROR: Workflow file missing TEST_DESCRIPTION environment variable"
            exit 1
          fi
          
          echo " ‚úÖ Workflow file validation passed"
        else
          echo " ‚ùå ERROR: Workflow file not found: $WORKFLOW_FILE"
          echo " This indicates a critical failure in workflow generation"
          exit 1
        fi

        # Add the workflow file to git
        git add "$WORKFLOW_FILE"
        echo " Workflow file added to git staging"

        # Show current branch
        echo " Current branch: $(git branch --show-current)"

    - name: Manage workflow file for enable/disable actions
      if: false
      run: |
        echo " Managing workflow file for action: create"
        
        CONFIG_NAME="${{ steps.process-action.outputs.config_name }}"
        SANITIZED_CONFIG_NAME=$(echo "$CONFIG_NAME" | sed 's/ /-/g' | sed 's/[^a-zA-Z0-9-]//g' | tr '[:upper:]' '[:lower:]')
        WORKFLOW_FILE=".github/workflows/daily-automation-$SANITIZED_CONFIG_NAME.yml"
        
        echo " Workflow file: $WORKFLOW_FILE"
        
        if [ -f "$WORKFLOW_FILE" ]; then
          echo " Workflow file exists, updating schedule..."
          
          if [ "create" = "enable" ]; then
            echo " Enabling scheduled runs..."
            # Ensure schedule is present and active
            if ! grep -q "schedule:" "$WORKFLOW_FILE"; then
              echo " Adding schedule trigger..."
              echo "  schedule:" > /tmp/schedule.txt
              echo "    - cron: '${{ inputs.cron_schedule }}'" >> /tmp/schedule.txt
              sed "/^on:/r /tmp/schedule.txt" "$WORKFLOW_FILE" > "$WORKFLOW_FILE.tmp" && mv "$WORKFLOW_FILE.tmp" "$WORKFLOW_FILE"
              rm /tmp/schedule.txt
            fi
          else
            echo " Disabling scheduled runs..."
            # Comment out the schedule section to disable it
            sed 's/^  schedule:/  # schedule:/' "$WORKFLOW_FILE" > "$WORKFLOW_FILE.tmp" && mv "$WORKFLOW_FILE.tmp" "$WORKFLOW_FILE"
            sed 's/^    - cron:/    # - cron:/' "$WORKFLOW_FILE" > "$WORKFLOW_FILE.tmp" && mv "$WORKFLOW_FILE.tmp" "$WORKFLOW_FILE"
          fi
          
          # Add to git staging
          git add "$WORKFLOW_FILE"
          echo " Workflow file updated and staged"
        else
          echo " Workflow file not found: $WORKFLOW_FILE"
          echo " This might be normal if the configuration was never created"
        fi

    - name: Commit and push changes
      if: steps.process-action.outputs.config_name != 'list' && steps.process-action.outputs.config_name != 'view'
      run: |
        echo " Committing configuration changes..."

        # Set git configuration
        git config --global user.email "github-actions[bot]@users.noreply.github.com"
        git config --global user.name "github-actions[bot]"

        # Set up authentication for pushing (use PAT for workflow file creation)
        if [ -n "${{ secrets.PERSONAL_ACCESS_TOKEN }}" ]; then
          echo " Using Personal Access Token for workflow file creation"
          git remote set-url origin https://x-access-token:${{ secrets.PERSONAL_ACCESS_TOKEN }}@github.com/${{ github.repository }}.git
        else
          echo " No Personal Access Token found - workflow file creation may fail"
          echo " Please add a PAT with 'workflow' scope as PERSONAL_ACCESS_TOKEN secret"
          git remote set-url origin https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git
        fi

        # Check if there are changes to commit
        echo " Debug: Checking for staged changes..."
        git status
        echo " Debug: Staged changes:"
        git diff --staged

        if git diff --staged --quiet; then
          echo " No changes to commit - this might be normal for some operations"
          echo " Debug: Let's check what files exist:"
          ls -la .github/workflows/
          echo " Debug: Let's check if config file exists:"
          ls -la .github/automation-configs/ || echo "No automation-configs directory"
          # Don't exit with error, just continue
        else
          # Commit with descriptive message
          COMMIT_MSG=" Create automation configuration: ${{ steps.process-action.outputs.config_name }}"

          # Add workflow file info to commit message
          SANITIZED_CONFIG_NAME=$(echo "${{ steps.process-action.outputs.config_name }}" | sed 's/ /-/g' | sed 's/[^a-zA-Z0-9-]//g' | tr '[:upper:]' '[:lower:]')
          WORKFLOW_FILE=".github/workflows/daily-automation-$SANITIZED_CONFIG_NAME.yml"

          if [ -f "$WORKFLOW_FILE" ]; then
            COMMIT_MSG="$COMMIT_MSG (workflow: daily-automation-$SANITIZED_CONFIG_NAME.yml)"
          fi

          git commit -m "$COMMIT_MSG"
          echo " Changes committed successfully"
        fi

        # Push to main branch (where workflow files are created)
        echo " Pushing to main branch..."
        if git push origin main; then
          echo " Successfully pushed to main branch"
        else
          echo " Failed to push to main branch"
          echo " This might be due to workflow file creation restrictions"
          echo " Try enabling 'Read and write permissions' in repository settings"
          echo " Or use a Personal Access Token with workflow permissions"
          # Don't exit with error, just warn
        fi

        # Add configuration file to the same commit (if not already staged)
        if [ -d ".github/automation-configs" ]; then
          git add .github/automation-configs/
          echo " Configuration files added to main branch"
        else
          echo " No automation-configs directory found"
        fi


    - name: Run test execution
      if: false
      run: |
        echo " Running test execution for configuration: ${{ steps.process-action.outputs.config_name }}"

        # Trigger the specific workflow
        SANITIZED_CONFIG_NAME=$(echo "${{ steps.process-action.outputs.config_name }}" | sed 's/ /-/g' | sed 's/[^a-zA-Z0-9-]//g' | tr '[:upper:]' '[:lower:]')
        WORKFLOW_FILE=".github/workflows/daily-automation-$SANITIZED_CONFIG_NAME.yml"

        echo " Triggering workflow: $WORKFLOW_FILE"
        echo "This will run the automation with the configured parameters"
        echo "Check the Actions tab to see the execution results"

    - name: Summary
      run: |
        echo "## üöÄ Scheduled Jobs Management Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Action Performed:** create" >> $GITHUB_STEP_SUMMARY
        echo "**Configuration:** ${{ steps.process-action.outputs.config_name }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY

        # Calculate sanitized config name for display
        SANITIZED_CONFIG_NAME=$(echo "${{ steps.process-action.outputs.config_name }}" | sed 's/ /-/g' | sed 's/[^a-zA-Z0-9-]//g' | tr '[:upper:]' '[:lower:]')

        case "create" in
          "create"|"update")
            echo " **Configuration created successfully!**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Configuration Name:** ${{ steps.process-action.outputs.config_name }}" >> $GITHUB_STEP_SUMMARY
            echo "**Cron Schedule:** ${{ inputs.cron_schedule }}" >> $GITHUB_STEP_SUMMARY
            echo "**Test Description:** [Provided successfully]" >> $GITHUB_STEP_SUMMARY
            echo "**Slack Channel:** ${{ inputs.slack_channel }}" >> $GITHUB_STEP_SUMMARY
            echo "**Headless Mode:** true" >> $GITHUB_STEP_SUMMARY
            echo "**Slack Notifications:** ${{ inputs.enable_slack }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo " **Configuration saved:** \`$SANITIZED_CONFIG_NAME\`" >> $GITHUB_STEP_SUMMARY
            echo " **Automated workflow created:** \`.github/workflows/daily-automation-$SANITIZED_CONFIG_NAME.yml\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo " **Configuration Status:**" >> $GITHUB_STEP_SUMMARY
            echo "-  Configuration saved to main branch" >> $GITHUB_STEP_SUMMARY
            echo "-  Scheduled workflow created in main branch" >> $GITHUB_STEP_SUMMARY
            echo "-  Ready to run automatically based on cron schedule" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo " **Next Steps:**" >> $GITHUB_STEP_SUMMARY
            echo "‚úÖ The workflow will run automatically based on your cron schedule" >> $GITHUB_STEP_SUMMARY
            echo "‚úÖ You can manually trigger it anytime from the Actions tab" >> $GITHUB_STEP_SUMMARY
            echo "‚úÖ Use 'Configure AI Test Automation' workflow to modify settings" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo " **Management Commands:**" >> $GITHUB_STEP_SUMMARY
            echo "- **View Details**: Run workflow with action 'view' and config name '${{ steps.process-action.outputs.config_name }}'" >> $GITHUB_STEP_SUMMARY
            echo "- **Disable Job**: Run workflow with action 'disable' and config name '${{ steps.process-action.outputs.config_name }}'" >> $GITHUB_STEP_SUMMARY
            echo "- **Enable Job**: Run workflow with action 'enable' and config name '${{ steps.process-action.outputs.config_name }}'" >> $GITHUB_STEP_SUMMARY
            echo "- **Update Settings**: Run workflow with action 'update' and modify parameters" >> $GITHUB_STEP_SUMMARY
            ;;

          "delete")
            echo " **Configuration deleted successfully!**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Deleted Configuration:** ${{ steps.process-action.outputs.config_name }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo " **Note:** The corresponding workflow file has been removed" >> $GITHUB_STEP_SUMMARY
            ;;

          "list")
            echo " **All Scheduled Job Configurations:**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`json" >> $GITHUB_STEP_SUMMARY
            echo '${{ steps.process-action.outputs.updated_configs }}' | jq '.' >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo " **Management Actions Available:**" >> $GITHUB_STEP_SUMMARY
            echo "- **Create New Job**: Run workflow with action 'create' and provide parameters" >> $GITHUB_STEP_SUMMARY
            echo "- **View Job Details**: Run workflow with action 'view' and specify config name" >> $GITHUB_STEP_SUMMARY
            echo "- **Update Job**: Run workflow with action 'update' and modify parameters" >> $GITHUB_STEP_SUMMARY
            echo "- **Enable/Disable Job**: Run workflow with action 'enable' or 'disable'" >> $GITHUB_STEP_SUMMARY
            echo "- **Delete Job**: Run workflow with action 'delete' and specify config name" >> $GITHUB_STEP_SUMMARY
            echo "- **Test Run Job**: Run workflow with action 'test-run' to execute immediately" >> $GITHUB_STEP_SUMMARY
            ;;

          "test-run")
            echo " **Test Run Initiated!**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Configuration:** ${{ steps.process-action.outputs.config_name }}" >> $GITHUB_STEP_SUMMARY
            echo "**Status:** Test execution triggered" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo " **Check the Actions tab to monitor the test execution**" >> $GITHUB_STEP_SUMMARY
            ;;

          "view")
            echo " **Configuration Details:**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Configuration:** ${{ steps.process-action.outputs.config_name }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`json" >> $GITHUB_STEP_SUMMARY
            echo '${{ steps.process-action.outputs.updated_configs }}' | jq --arg name "${{ steps.process-action.outputs.config_name }}" '.[$name]' >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            ;;

          "enable")
            echo " **Configuration Enabled!**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Configuration:** ${{ steps.process-action.outputs.config_name }}" >> $GITHUB_STEP_SUMMARY
            echo "**Status:** Active - Scheduled runs will execute" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo " **The scheduled workflow will now run according to its cron schedule**" >> $GITHUB_STEP_SUMMARY
            ;;

          "disable")
            echo " **Configuration Disabled!**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Configuration:** ${{ steps.process-action.outputs.config_name }}" >> $GITHUB_STEP_SUMMARY
            echo "**Status:** Inactive - Scheduled runs are paused" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo " **The scheduled workflow will not run until re-enabled**" >> $GITHUB_STEP_SUMMARY
            ;;
        esac

        echo "" >> $GITHUB_STEP_SUMMARY
        echo " **üîó Useful Links:**" >> $GITHUB_STEP_SUMMARY
        echo "- [GitHub Actions Dashboard](https://github.com/${{ github.repository }}/actions)" >> $GITHUB_STEP_SUMMARY
        echo "- [Configuration Files](https://github.com/${{ github.repository }}/tree/main/.github/automation-configs)" >> $GITHUB_STEP_SUMMARY
        echo "- [Generated Workflows](https://github.com/${{ github.repository }}/tree/main/.github/workflows)" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo " **üìã Quick Reference:**" >> $GITHUB_STEP_SUMMARY
        echo "All scheduled job management is done through GitHub Actions workflow:" >> $GITHUB_STEP_SUMMARY
        echo "1. Go to Actions tab ‚Üí 'Configure AI Test Automation'" >> $GITHUB_STEP_SUMMARY
        echo "2. Click 'Run workflow'" >> $GITHUB_STEP_SUMMARY
        echo "3. Select action and provide parameters" >> $GITHUB_STEP_SUMMARY
        echo "4. View results in the workflow run summary" >> $GITHUB_STEP_SUMMARY